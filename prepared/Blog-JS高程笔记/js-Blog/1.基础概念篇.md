阅读JS高程，及时留下笔记、新得、扩展
一直在纠结要不要记录最最基本的内容，比如标识，格式等等，最后决定事无巨细～
# 一、基本概念
> 任何语言的核心都必然会描述这么语言的最基本的工作原理。而描述的内容通常都要涉及这门语言的语法、操作符、数据诶行、内置功能等用于构建复杂解决方案的基本概念。
## 1.1 语法

### 1.1.1区分大小写
要清楚的知道，ECMAScript中的一切（变量、函数名和操作符）都区分大小写。
### 1.1.2标识符
所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：
1.第一个字符必须是一个字母、下划线、美元符号。
2.其他字符可以是字母、下划线、美元符号或数字。
> 按照惯例，标识符采用驼峰大小写格式，也就是第一个字母消协，剩下的每个单词首字母大写，例如onClickBtn（这么写，莫名的高大上有米有）

### 1.1.3严格模式
ECMAScript 5 引入了严格模式(strict mode)的概念。严格模式是为 JavaScript 定义了一种不同的 解析与执行模型。
在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全 的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码:
```js
    "use strict";

```
这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示(pragma)， 用于告诉支持的 JavaScript 引擎切换到严格模式。
这是为不破坏 ECMAScript 3 语法而特意选定的语法。
  在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行:
```js
function doSomething(){
   "use strict";//函数体 
}
```

## 1.2 标识符注意点

>虽然省略var操作符可以定义全局变量，但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护，而且如果有意的忽略var操作符，也会在局部
作用域中定义的全局变量很难维护，而且如果有意的忽略了var操作符，也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变脸赋值在严格模式下会
导致抛出ReferenceError错误

## 1.3 数据类型

ECMAScript 中有 5 种简单数据类型(也称为基本数据类型):Undefined、Null、Boolean、Number 和 String。
还有 1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。

### 1.3.1 typeof操作符
鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof 就 是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串:

"undefined"——如果这个值未定义; 
"boolean"——如果这个值是布尔值; 
"string"——如果这个值是字符串;
"number"——如果这个值是数值;
"object"——如果这个值是对象或 null;
"function"——如果这个值是函数。

下面的几个例子说明，typeof 操作符的操作数可以是变量(message)，也可以是数值字面量。
注意，typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。
```js
alert(typeof message);  //string
alert(typeof(message)); //string
alert(typeof 95); //number
```
有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null 会返回"object"，因为特殊值 null 被认为是一个空的对象引用。Safari 5 及之前版本、Chrome 7 及之 前版本在对正则表达式调用 typeof 操作符时会返回"function"，而其他浏览器在这种情况下会返回 "object"。


### 1.3.2 undefined类型
Undefined 类型只有一个值，即特殊的 undefined。
*在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined*，
例如: 
```js
var message;
alert(message == undefined); //true
```
### 1.3.3 null类型
Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表 示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因，如下面 的例子所示:

```js
var jbj = null;
console.log(jbj); // object
```
在这里null和undefined之前的用 == 判断时，总是返回true，但是两者并不相同，我们可以主动的让变量保存null值，这样做可以体现null作为控对象指针的惯例。

### 1.3.4 boolean类型
Boolean 类型是 ECMAScript 中使用得最多的一种类型，该类型只有两个字面值:true 和 false。 这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于 0。以下是为变量赋 Boolean 类型值的例子:
```js
var found = true;
var lost = false;
```
需要注意的是，Boolean 类型的字面值 true 和 false 是区分大小写的。也就是说，True 和 False (以及其他的混合大小写形式)都不是 Boolean 值，只是标识符。
虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值 等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()，如下例所示:
```js
var message = "Hello world!";
var messageAsBoolean = Boolean(message);
```

### 1.3.5 number类型
Number 类型应该是 ECMAScript 中最令人关注的数据类型了，这种类型使用 IEEE754 格式来表示 整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。
为支持各种数值类型，ECMA-262 定 义了不同的数值字面量格式。

*最基本的就是字面量是十进制整数*
```js
var intNum = 10;
```

除了以十进制表示外，整数还可以通过八进制(以 8 为基数)或十六进制(以 16 为基数)的字面值 来表示。
其中，八进制字面值的第一位必须是零(0)，然后是八进制数字序列(0~7)。如果字面值中的 数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。
请看下面的例子:
```js
var octalNum1 = 070; // 八进制的 56
var octalNum2 = 079; // 无效的八进制数值——解析为 79
var octalNum3 = 08;  // 无效的八进制数值——解析为 8
```
*八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。*

十六进制字面值的前两位必须是 0x，后跟任何十六进制数字(0~9 及 A~F)。其中，字母 A~F 可以大写，也可以小写。如下面的例子所示:
```js
var hexNum1 = 0xA; // 十六进制的 10 
var hexNum2 = 0x1f; // 十六进制的 31
```  
*在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值*

## 数字之中容易被忽略的浮点数

### 1.浮点数值
所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小 数点前面可以没有整数，但我们不推荐这种写法。以下是浮点数值的几个例子:
```js
var floatNum1 = 1.1;
var floatNum2 = 0.1;
var floatNum3 = .1; // 有效，但不推荐
```

由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值 *转换为整数值*。
显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。
同样地，如果浮点数值本身表示的就是一个整数(如 1.0)，那么该值也会被转换为整数，如下面的例子所示:
```js
var floatNum1 = 1.; // 小数点后面没有数字——解析为 1 
var floatNum2 = 10.0; // 整数——解析为 10
```

对于那些极大或极小的数值，可以用 e 表示法(即科学计数法)表示的浮点数值表示。用 e 表示法 表示的数值等于 e 前面的数值乘以 10 的指数次幂。
ECMAScript 中 e 表示法的格式也是如此，即前面是 一个数值(可以是整数也可以是浮点数)，中间是一个大写或小写的字母 E，后面是 10 的幂中的指数， 该幂值将用来与前面的数相乘。
下面是一个使用 e 表示法表示数值的例子:
```js
var floatNum = 3.125e7; // 等于31250000
```
在默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法 表示的数值(例如，0.0000003 会被转换成 3e7)。
浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。 
例如:
```js
if (a + b == 0.3){ 
    ("You got 0.3.");// 不要做这样的测试! alert
}
```
在这个例子中，我们测试的是两个数的和是不是等于 0.3。如果这两个数是 0.05 和 0.25，或者是 0.15 和 0.15 都不会有问题。
而如前所述，如果这两个数是 0.1 和 0.2，那么测试将无法通过。因此，永远不 要测试某个特定的浮点数值。

> 关于浮点数值计算会产生舍入误差的问题，有一点需要明确:这是使用基于 IEEE754 数值的浮点计算的通病，
ECMAScript 并非独此一家;其他使用相同数值格 式的语言也存在这个问题。[看百度百科对IEEE754浮点计算的介绍](https://baike.baidu.com/item/IEEE%20754)

### 2.NaN

NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作(例如 NaN/10)都会返回 NaN，这 个特点在多步计算中有可能导致问题。
其次，NaN 与任何值都不相等，包括 NaN 本身。例如，下面的代码会返回 false:
```js
console.log(NaN == NaN)
```
     
针对 `NaN` 的这两个特点，ECMAScript 定义了 `isNaN()`函数。这个函数接受一个参数，该参数可以 是任何类型，而函数会帮我们确定这个参数是否“不是数值”。
isNaN()在接收到一个值之后，会尝试 将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串"10"或 Boolean 值。
而任何 不能被转换为数值的值都会导致这个函数返回 true。
请看下面的例子:
```js
alert(isNaN(NaN));     //true
alert(isNaN(10));      //false(10 是一个数值)
alert(isNaN("10"));    //false(可以被转换成数值 10)
alert(isNaN("blue"));  //true(不能转换成数值)
alert(isNaN(true));    //false(可以被转换成数值 1)
```

### 1.3.6 String类型

String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。字符串可以由双引号(")或单引号(')表示，
因此下面两种字符串的写法都是有效的: 

```js
var firstName = "Nicholas"`;
var lastName = 'Zakas';
```

### 1. 字符串的特点
ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变 某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量， 
例如:
```js
var lang = "Java";
lang = lang + "Script";
```
以上示例中的变量 lang 开始时包含字符串"Java"。而第二行代码把 lang 的值重新定义为"Java" 与"Script"的组合，即"JavaScript"。
实现这个操作的过程如下:首先创建一个能容纳 10 个字符的 新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁原来的字符串"Java"和字 符串"Script"，因为这两个字符串已经没用了。
这个过程是在后台发生的，而这也是在某些旧版本的

### 2. 转换为字符串
要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString()方法(第 5 章将讨论这个方法的特点)。
这个方法唯一要做的就是返回相应值的字符串表现。来看下面的例子:
```js
var age = 11;
var ageAsString = age.toString(); // 字符串"11" 
var found = true;
var foundAsString = found.toString(); // 字符串"true"
```
数值、布尔值、对象和字符串值(没错，每个字符串也都有一个 toString()方法，该方法返回字 符串的一个副本)都有 toString()方法。但 null 和 undefined 值没有这个方法。
多数情况下，调用 toString()方法不必传递参数。但是，在调用数值的 toString()方法时，可 以传递一个参数:输出数值的基数。默认情况下，toString()方法以十进制格式返回数值的字符串表 示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格 式表示的字符串值。下面给出几个例子:
```js
var num = 10;
alert(num.toString());   // "10"
alert(num.toString(2));  // "1010"
alert(num.toString(8));  // "12"
alert(num.toString(10)); // "10"
alert(num.toString(16)); // "a"
```
注意，默认的(没有参数的)输出值与指定基数 10 时 的输出值相同。
在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String()，这个函数能够将任何类型的值转换为字符串。
String()函数遵循下列转换规则:
 - 如果值有 toString()方法，则调用该方法(没有参数)并返回相应的结果;
 - 如果值是 null，则返回"null";
 - 如果值是 undefined，则返回"undefined"。
下面再看几个例子:
```js
var value1 = 10;
var value2 = true;
var value3 = null;
var value4;
alert(String(value1)); // "10"
alert(String(value2)); // "true"
alert(String(value3)); // "null"
alert(String(value4)); // "undefined"
```
这里先后转换了 4 个值:数值、布尔值、null 和 undefined。数值和布尔值的转换结果与调用 toString()方法得到的结果相同。
因为 null 和 undefined 没有 toString()方法，所以 String() 函数就返回了这两个值的字面量。

要把某个值转换为字符串，可以使用加号操作符(3.5 节讨论)把它与一个字符 串("")加在一起。

### 1.3.7 Object类型
> ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建 的对象类型的名称来创建。
而创建 Object 类型的实例并为其添加属性和(或)方法，就可以创建自定 义对象，如下所示:
```js
var o = new Object();
```
这个语法与 Java 中创建对象的语法相似;但在 ECMAScript 中，如果不给构造函数传递参数，则可 以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那 对圆括号(但这不是推荐的做法):
`var o = new Object; // 有效，但不推荐省略圆括号`
仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想:即在 ECMAScript 中， (就像 Java 中的 java.lang.Object 对象一样)Object 类型是所有它的实例的基础。
换句话说,Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object 的每个实例都具有下列属性和方法。
 - constructor:保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor) 就是 Object()。
 - hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定(例 如:o.hasOwnProperty("name"))。
 - isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型(第 5 章将讨论原 型)。
 - propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句 (本章后面将会讨论)来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
 - toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应。
 - toString():返回对象的字符串表示。 
 - valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。
由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。

